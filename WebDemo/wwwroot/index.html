<!DOCTYPE html>
<html>

<head>
  <link href="vue/materialdesignicons.min.css" rel="stylesheet">
  <link href="fonts/roboto/roboto.css" rel="stylesheet">
  <link href="vue/vuetify.min.css" rel="stylesheet">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
  <!-- Vue.js and Vuetify libraries -->
  <script src="vue/vue.min.js"></script>
  <script src="vue/vuetify.min.js"></script>
  <style>
    .md3-dialog {
      border-radius: 32px !important;
    }
  </style>
</head>

<body>
  <div id="app">
    <!-- Main Vue application container -->
    <v-app>

      <!-- Configuration dialog for managing tracking numbers -->
      <v-dialog persistent v-model="openConfig" max-width="600px">

        <v-card class="md3-dialog animated-enter" elevation="12">

          <v-card-title>
            <v-btn :disabled="!hasClientName" icon @click="openConfig = false">
              <v-icon>mdi-close</v-icon>
            </v-btn>

            <h3 class="col-6">Tracking numbers</h3>

            <v-spacer></v-spacer>

            <!-- Refresh interval configuration -->
            <v-text-field class="align-start col-3" v-model="intervalTime"
                          :rules="[computedInternvalTimeout >= minimummTimeout || 'Timeout should upper 30s']"
                          v-show="hasClientName" rounded hide-details="auto" label="Timeout" type="number" :min="minimummTimeout"
                          dense class="mt-3" width="100px" outlined>

              <template v-slot:append>
                <v-menu offset-y>
                  <template v-slot:activator="{ on, attrs }">
                    <v-btn primary style="margin: -2px -16px 0 0" small text rounded v-bind="attrs" v-on="on">
                      {{ timeParts[intervalTimePart][0] }}
                    </v-btn>
                  </template>
                  <v-list dense>
                    <v-list-item v-for="(part, index) in timeParts" :key="index" @click="intervalTimePart = index">
                      <v-list-item-title>{{ part }}</v-list-item-title>
                    </v-list-item>
                  </v-list>
                </v-menu>
              </template>

            </v-text-field>

          </v-card-title>

          <v-divider></v-divider>

          <v-card-text>
            <v-text-field min="4" rounded v-show="!hasClientName" v-model="editClientName" hide-details="auto"
                          label="Client name" outlined :rules="nameRules" class="mt-6"
                          @keypress.enter="!cantSaveName && saveName()">
              <v-icon :disabled="cantSaveName" class="mx-2" slot="append-outer" @click="saveName">
                mdi-content-save-check-outline
              </v-icon>
            </v-text-field>

            <v-row class="my-5 ml-0" v-show="hasClientName">
              <v-text-field class="align-start col-6" v-model="trackingNumberEdit" v-show="hasClientName" rounded hide-details="auto" 
                            :rules="rules.concat(v => !(v?.trim() in this.logs) || 'Number already exists')" label="Tracking number" 
                            dense outlined ref="trackingNumberInput"
                            @keypress.enter="!cantAddTrackingNumber && addTrackingNumber(trackingNumberEdit)">
                <v-icon :disabled="cantAddTrackingNumber" class="mr-3" slot="append-outer"
                  @click="addTrackingNumber(trackingNumberEdit)">
                  mdi-plus
                </v-icon>
              </v-text-field>
            </v-row>

            <v-list v-show="hasClientName">
              <v-list-item v-for="key in Object.keys(logs)" :key="key">
                <v-list-item-content>
                  <v-list-item-title>#{{ key }}</v-list-item-title>
                </v-list-item-content>
                <v-list-item-action>
                  <v-btn icon small @click="removeTrackingNumber(key)">
                    <v-icon>mdi-close</v-icon>
                  </v-btn>
                </v-list-item-action>
              </v-list-item>
              <v-list-item v-if="Object.keys(logs).length === 0">
                <v-list-item-content>
                  <v-list-item-subtitle class="text-center">No tracking numbers added yet</v-list-item-subtitle>
                </v-list-item-content>
              </v-list-item>
            </v-list>
          </v-card-text>

          <v-divider v-if="hasClientName"></v-divider>

          <v-card-actions v-if="hasClientName">
            <v-spacer></v-spacer>
            <v-btn :disabled="!nonTrackedNumbers.length" @click="openConfig = false; watchForNumbers()" outlined rounded
              class="mr-3 pr-4 my-4" color="primary">
              <v-icon left>mdi-eye-arrow-right</v-icon>
              Track
            </v-btn>
          </v-card-actions>

        </v-card>

      </v-dialog>

      <v-main>
        <v-container>
          <v-row class="my-4 mx-4">
            <v-spacer></v-spacer>
            <div>
              <v-list-item>
                <v-list-item-content>
                  <v-list-item-title class="text-right">{{currentClient || 'Guess'}}</v-list-item-title>
                  <!-- <v-list-item-subtitle class="text-right">refresh {{computedInternvalTimeout}}</v-list-item-subtitle> -->
                </v-list-item-content>
                <v-list-item-action>
                  <v-badge :value="!!currentClient" color="red" overlap>
                    <v-icon slot="badge" @click="clearSession">mdi-close</v-icon>
                    <v-avatar size="64">
                      <v-icon size="60">mdi-account-circle</v-icon>
                    </v-avatar>
                  </v-badge>
                </v-list-item-action>
              </v-list-item>
            </div>
          </v-row>
          <v-row class="my-4 mx-4" v-show="!hasntLogs">
            <v-spacer></v-spacer>
            <v-btn outlined rounded color="primary" right @click="openConfig = true">
              <v-icon left>mdi-plus</v-icon>
              Add tracking numbers
            </v-btn>
          </v-row>
          <v-row v-if="hasntLogs" class="my-8">
            <v-col class="text-center">
              <v-icon size="84" color="grey lighten-1" class="mb-4">mdi-package-variant-closed</v-icon>
              <h2 class="grey--text text--darken-1">No tracking numbers yet</h2>
              <p class="grey--text text-caption">Add tracking numbers to start monitoring your shipments</p>
              <v-btn color="primary" class="mt-3" rounded outlined @click="openConfig = true">
                <v-icon left>mdi-plus</v-icon>
                Add your first tracking numbers
              </v-btn>
            </v-col>
          </v-row>
          <v-expansion-panels multiple class="md3-dialog" popout>
            <v-expansion-panel :readonly="!update.history.length" v-for="[num, update] in Object.entries(logs)">
              <v-expansion-panel-header :ripple="update.history.length">
                <v-row justify="space-between" align="center">
                  <v-col cols="auto">
                    <v-avatar>
                      <v-icon>mdi-truck-delivery</v-icon>
                      <v-progress-circular v-show="isLoading(num)" style="position: absolute;" indeterminate
                        size="44" />
                    </v-avatar>
                  </v-col>
                  <v-col>
                    <h3 class="mb-2">#{{num}}</h3>
                    <v-chip x-small v-if="update.failCount" color="red">
                      Attempt #{{update.failCount}}: Could not retrieve data from given providers
                    </v-chip>
                    <span v-if="update.lastUpdated" class="text--secondary">{{update.lastUpdated | toRelative}}</span>
                    <span v-else class="text--secondary">(Not updated)</span>
                  </v-col>
                  <v-col align="end" cols="1">                    
                    <v-chip class="mr-2" small v-if="update.isCompleted" color="success">
                      COMPLETED
                    </v-chip>
                    <v-btn class="mr-2" v-else-if="!isLoading(num)" icon small @click.stop.prevent="watchForNumbers([num])">
                      <v-icon>mdi-refresh</v-icon>
                    </v-btn>
                  </v-col>
                </v-row>
              </v-expansion-panel-header>
              <v-expansion-panel-content>
                <v-list-item v-for="log in update.history" :key="log.timestamp">
                  <v-list-item-content>
                    <v-list-item-title>{{ log.company || 'Unknown location' }}</v-list-item-title>
                    <v-list-item-subtitle>{{ log.location || 'Unknown company ' }}</v-list-item-subtitle>
                  </v-list-item-content>
                  <v-list-item-action>
                    <v-chip color="success">{{log.status}}</v-chip>
                    <span class="pt-2 v-list-item__subtitle">{{log.timestamp | toRelative}}</span>
                  </v-list-item-action>
                </v-list-item>
              </v-expansion-panel-content>
            </v-expansion-panel>
          </v-expansion-panels>
        </v-container>
      </v-main>
    </v-app>
  </div>

  <style>
    @keyframes dialog-enter {
      0% {
        transform: translate(0, -100px) scale(0.7);
        opacity: 0;
      }

      100% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
      }
    }

    .animated-enter {
      animation: dialog-enter 0.3s ease-out forwards;
      /* transform-origin: center; */
    }
  </style>

  <script type="module">
    import { HubConnectionBuilder } from "./signalr.min.js"
      import { read, write } from './localstore.js'

      // Retrieve client name from local storage or default to empty string
      let clientName = read('currentClient') || '';

      // Constants and configuration
      const TIMEOUT = 3 * 60 * 1000,  // Default timeout: 3 minutes in milliseconds
        parts = {  // Time unit conversion factors
          s: 1000,
          m: 60 * 1000,
          h: 60 * 60 * 1000
        },
        // Retrieve interval settings from local storage or use defaults
        [intervalTime, intervalTimePart] = (read(`${clientNameAsId(clientName)}_interval`) ?? [3, 1]),
        // Formatter for relative time display
        rtf = new Intl.RelativeTimeFormat('en', { numeric: 'auto' });

      new Vue({
        el: '#app',
        vuetify: new Vuetify({
          theme: {
            // Auto-detect dark mode from system preferences
            dark: window.matchMedia?.('(prefers-color-scheme: dark)')?.matches ?? true
          }
        }),
        // Custom filters for data formatting
        filters: {
          // Convert timestamps to relative time format (e.g., "2 hours ago")
          toRelative(v)
          {
            const now = Date.now(),
              diffMs = new Date(v) - now,
              diffSeconds = Math.round(diffMs / 1000),
              diffMinutes = Math.round(diffSeconds / 60),
              diffHours = Math.round(diffMinutes / 60),
              diffDays = Math.round(diffHours / 24),
              diffWeeks = Math.round(diffDays / 7),
              diffMonths = Math.round(diffDays / 30.42), // Average days per month
              diffYears = Math.round(diffDays / 365.25); // Average days per year (accounting for leap years)

            // Return the appropriate time unit based on the difference magnitude
            if (Math.abs(diffYears) >= 1) return rtf.format(diffYears, 'year');
            if (Math.abs(diffMonths) >= 1) return rtf.format(diffMonths, 'month');
            if (Math.abs(diffWeeks) >= 1) return rtf.format(diffWeeks, 'week');
            if (Math.abs(diffDays) >= 1) return rtf.format(diffDays, 'day');
            if (Math.abs(diffHours) >= 1) return rtf.format(diffHours, 'hour');
            if (Math.abs(diffMinutes) >= 1) return rtf.format(diffMinutes, 'minute');
            if (Math.abs(diffSeconds) >= 1) return rtf.format(diffSeconds, 'second');
            return rtf.format(0, 'second'); // Fallback for no difference
          }
        },
        computed: {
          // Calculate the actual timeout value based on interval time and unit
          computedInternvalTimeout()
          {
            return this.intervalTime * parts[this.timeParts[this.intervalTimePart][0]] || TIMEOUT;
          },
          // List of tracking numbers that aren't currently being loaded
          nonTrackedNumbers()
          {
            return Object.keys(this.logs).filter(tn => !this.logs[tn].isCompleted && !this.isLoading(tn));
          },
          // Check if there are no logs to display
          hasntLogs()
          {
            return Object.keys(this.logs).length === 0
          },
          // Check if user has provided a client name
          hasClientName()
          {
            return !!this.currentClient?.trim()
          },
          // Validation logic for client name
          cantSaveName()
          {
            return this.nameRules.some(r => typeof r === "string");
          },
          nameRules()
          {
            return this.rules.map(r => r(this.editClientName.trim()));
          },
          // Validation logic for tracking numbers
          cantAddTrackingNumber()
          {
            return this.trackingNumberRules.some(r => typeof r === "string");
          },
          trackingNumberRules()
          {
            return this.rules
              .concat(v => !(v?.trim() in this.logs) || "Number already exists")
              .map(r => r(this.trackingNumberEdit.trim()));
          }
        },
        data: {
          trackingNumberEdit: '',
          minimummTimeout: TIMEOUT,
          editClientName: '',
          loadingItems: [],
          intervalRef: null,
          intervalTime,
          intervalTimePart,
          timeParts: ['second(s)', 'minute(s)', 'hour(s)'],
          currentClient: clientName,
          openConfig: false,
          rules: [
            v => !!v || 'Value is required',
            v => (v.length > 4) || 'Value must be less than 4 characters',
          ],
          logs: read(clientNameAsId(clientName)) ?? {},
          signalRConnection: new HubConnectionBuilder().withUrl("/ordertracker").build()
        },
        watch: {
          computedInternvalTimeout(v)
          {
            if (v > TIMEOUT)
            {
              write(`${clientNameAsId(clientName)}_interval`, [this.intervalTime, this.intervalTimePart]);
            }
          }
        },
        created()
        {
          this.connect().then();
        },
        methods: {
          // Reset all application data and local storage
          clearSession()
          {
            Object.keys(localStorage).forEach(key =>
            {
              localStorage.removeItem(key);
            });
            this.currentClient = this.editClientName = this.trackingNumberEdit = '';
            this.logs = {};
            this.loadingItems = [];
            this.openConfig = true;
            if (this.intervalRef)
            {
              clearInterval(this.intervalRef);
            }
          },
          // Store client name and initialize logs
          saveName()
          {
            write('currentClient', this.currentClient = this.editClientName);
            write(clientNameAsId(this.currentClient), this.logs = {});
          },
          // Add a new tracking number to monitor
          addTrackingNumber(trackingNumber)
          {
            this.$set(this.logs, trackingNumber, { lastUpdated: null, history: [] });
            write(clientNameAsId(this.currentClient), this.logs);
            this.trackingNumberEdit = '';
            $refs.trackingNumberInput.resetValidation();
          },
          // Remove a tracking number and save changes
          removeTrackingNumber(key)
          {
            this.removeLoadingItem(key);
            this.$delete(this.logs, key);
            this.$nextTick(() => write(clientNameAsId(this.currentClient), this.logs));
          },
          // Check if a tracking number is currently being loaded
          isLoading(key)
          {
            return this.loadingItems.includes(key);
          },
          // Mark tracking numbers as loading
          addLoadingItems(...tracingNumbers)
          {
            this.loadingItems.push(...tracingNumbers);
          },
          // Remove tracking numbers from loading state
          removeLoadingItem(...tracingNumbers)
          {
            this.loadingItems = this.loadingItems.filter(tn => !tracingNumbers.includes(tn));
          },
          // Establish SignalR connection to the tracking service
          async connect()
          {
            try
            {
              await this.signalRConnection.start();
              this.signalRConnection.on("Update", this.receiveUpdates);
              console.log("SignalR connected");
              this.watchForNumbers();
            } catch (err)
            {
              console.error("Error connecting to SignalR:", err);
            }
          },
          // Main tracking method - requests updates for tracking numbers
          watchForNumbers(numbersToTrack = this.nonTrackedNumbers)
          {
            // Exit if SignalR is not connected
            if (this.signalRConnection.state !== "Connected")
            {
              console.log("SignalR not connected, attempting to connect...");
              return; // Don't proceed if not connected
            }
            if (this.intervalRef !== null)
            {
              clearInterval(this.interval);
            }

            if (!numbersToTrack.length)
            {
              return;
            }

            this.addLoadingItems(...numbersToTrack);

            this.signalRConnection.invoke('UpdateConnectionIdAsync', this.currentClient, numbersToTrack).then();

            // Schedule next update based on configured interval
            this.intervalRef = setInterval(this.watchForNumbers, this.computedInternvalTimeout);
          },
          // Handle tracking updates from the server
          receiveUpdates({ trackingNumber, history })
          {
            if(!(trackingNumber in this.logs)) return;

            this.removeLoadingItem(trackingNumber);

            let failCount = this.logs[trackingNumber]?.failCount ?? 0;
            const oldHistory = this.logs[trackingNumber]?.history;

            if (!history.length)
            {
              if (!!oldHistory?.length) history = oldHistory;
              failCount++;
            }
            else
            {
              failCount = 0
            }

            const firstLog = history[0];

            this.$set(this.logs, trackingNumber, { 
              failCount,
              history , 
              isCompleted: firstLog?.isCompleted, 
              status: firstLog?.status, 
              lastUpdated: firstLog?.timestamp
            });
            
            write(clientNameAsId(this.currentClient), this.logs);
          }
        }
      });

      // Helper function to create a safe storage key from client name
      function clientNameAsId(client)
      {
        return client.replaceAll(/[^\w]+/g, '_') + "_logs";
      }
  </script>
</body>

</html>