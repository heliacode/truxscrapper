var j=((K)=>typeof require!=="undefined"?require:typeof Proxy!=="undefined"?new Proxy(K,{get:($,G)=>(typeof require!=="undefined"?require:$)[G]}):K)(function(K){if(typeof require!=="undefined")return require.apply(this,arguments);throw Error('Dynamic require of "'+K+'" is not supported')});class S extends Error{constructor(K,$){let G=new.target.prototype;super(`${K}: Status code '${$}'`);this.statusCode=$,this.__proto__=G}}class x extends Error{constructor(K="A timeout occurred."){let $=new.target.prototype;super(K);this.__proto__=$}}class A extends Error{constructor(K="An abort occurred."){let $=new.target.prototype;super(K);this.__proto__=$}}class m extends Error{constructor(K,$){let G=new.target.prototype;super(K);this.transport=$,this.errorType="UnsupportedTransportError",this.__proto__=G}}class u extends Error{constructor(K,$){let G=new.target.prototype;super(K);this.transport=$,this.errorType="DisabledTransportError",this.__proto__=G}}class p extends Error{constructor(K,$){let G=new.target.prototype;super(K);this.transport=$,this.errorType="FailedToStartTransportError",this.__proto__=G}}class f extends Error{constructor(K){let $=new.target.prototype;super(K);this.errorType="FailedToNegotiateWithServerError",this.__proto__=$}}class i extends Error{constructor(K,$){let G=new.target.prototype;super(K);this.innerErrors=$,this.__proto__=G}}class F{constructor(K,$,G){this.statusCode=K,this.statusText=$,this.content=G}}class N{get(K,$){return this.send({...$,method:"GET",url:K})}post(K,$){return this.send({...$,method:"POST",url:K})}delete(K,$){return this.send({...$,method:"DELETE",url:K})}getCookieString(K){return""}}var W;(function(K){K[K.Trace=0]="Trace",K[K.Debug=1]="Debug",K[K.Information=2]="Information",K[K.Warning=3]="Warning",K[K.Error=4]="Error",K[K.Critical=5]="Critical",K[K.None=6]="None"})(W||(W={}));class C{constructor(){}log(K,$){}}C.instance=new C;var GK="8.0.7";class B{static isRequired(K,$){if(K===null||K===void 0)throw new Error(`The '${$}' argument is required.`)}static isNotEmpty(K,$){if(!K||K.match(/^\s*$/))throw new Error(`The '${$}' argument should not be empty.`)}static isIn(K,$,G){if(!(K in $))throw new Error(`Unknown ${G} value: ${K}.`)}}class w{static get isBrowser(){return!w.isNode&&typeof window==="object"&&typeof window.document==="object"}static get isWebWorker(){return!w.isNode&&typeof self==="object"&&"importScripts"in self}static get isReactNative(){return!w.isNode&&typeof window==="object"&&typeof window.document==="undefined"}static get isNode(){return typeof process!=="undefined"&&process.release&&process.release.name==="node"}}function R(K,$){let G="";if(k(K)){if(G=`Binary data of length ${K.byteLength}`,$)G+=`. Content: '${zK(K)}'`}else if(typeof K==="string"){if(G=`String data of length ${K.length}`,$)G+=`. Content: '${K}'`}return G}function zK(K){let $=new Uint8Array(K),G="";return $.forEach((Z)=>{let Y=Z<16?"0":"";G+=`0x${Y}${Z.toString(16)} `}),G.substr(0,G.length-1)}function k(K){return K&&typeof ArrayBuffer!=="undefined"&&(K instanceof ArrayBuffer||K.constructor&&K.constructor.name==="ArrayBuffer")}async function y(K,$,G,Z,Y,X){let J={},[V,Q]=H();J[V]=Q,K.log(W.Trace,`(${$} transport) sending data. ${R(Y,X.logMessageContent)}.`);let _=k(Y)?"arraybuffer":"text",P=await G.post(Z,{content:Y,headers:{...J,...X.headers},responseType:_,timeout:X.timeout,withCredentials:X.withCredentials});K.log(W.Trace,`(${$} transport) request complete. Response status: ${P.statusCode}.`)}function ZK(K){if(K===void 0)return new b(W.Information);if(K===null)return C.instance;if(K.log!==void 0)return K;return new b(K)}class l{constructor(K,$){this._subject=K,this._observer=$}dispose(){let K=this._subject.observers.indexOf(this._observer);if(K>-1)this._subject.observers.splice(K,1);if(this._subject.observers.length===0&&this._subject.cancelCallback)this._subject.cancelCallback().catch(($)=>{})}}class b{constructor(K){this._minLevel=K,this.out=console}log(K,$){if(K>=this._minLevel){let G=`[${new Date().toISOString()}] ${W[K]}: ${$}`;switch(K){case W.Critical:case W.Error:this.out.error(G);break;case W.Warning:this.out.warn(G);break;case W.Information:this.out.info(G);break;default:this.out.log(G);break}}}}function H(){let K="X-SignalR-User-Agent";if(w.isNode)K="User-Agent";return[K,QK(GK,_K(),BK(),wK())]}function QK(K,$,G,Z){let Y="Microsoft SignalR/",X=K.split(".");if(Y+=`${X[0]}.${X[1]}`,Y+=` (${K}; `,$&&$!=="")Y+=`${$}; `;else Y+="Unknown OS; ";if(Y+=`${G}`,Z)Y+=`; ${Z}`;else Y+="; Unknown Runtime Version";return Y+=")",Y}function _K(){if(w.isNode)switch(process.platform){case"win32":return"Windows NT";case"darwin":return"macOS";case"linux":return"Linux";default:return process.platform}else return""}function wK(){if(w.isNode)return process.versions.node;return}function BK(){if(w.isNode)return"NodeJS";else return"Browser"}function M(K){if(K.stack)return K.stack;else if(K.message)return K.message;return`${K}`}function YK(){if(typeof globalThis!=="undefined")return globalThis;if(typeof self!=="undefined")return self;if(typeof window!=="undefined")return window;if(typeof global!=="undefined")return global;throw new Error("could not find global")}class g extends N{constructor(K){super();if(this._logger=K,typeof fetch==="undefined"||w.isNode){let $=typeof __webpack_require__==="function"?__non_webpack_require__:j;if(this._jar=new($("tough-cookie")).CookieJar,typeof fetch==="undefined")this._fetchType=$("node-fetch");else this._fetchType=fetch;this._fetchType=$("fetch-cookie")(this._fetchType,this._jar)}else this._fetchType=fetch.bind(YK());if(typeof AbortController==="undefined"){let $=typeof __webpack_require__==="function"?__non_webpack_require__:j;this._abortControllerType=$("abort-controller")}else this._abortControllerType=AbortController}async send(K){if(K.abortSignal&&K.abortSignal.aborted)throw new A;if(!K.method)throw new Error("No method defined.");if(!K.url)throw new Error("No url defined.");let $=new this._abortControllerType,G;if(K.abortSignal)K.abortSignal.onabort=()=>{$.abort(),G=new A};let Z=null;if(K.timeout){let V=K.timeout;Z=setTimeout(()=>{$.abort(),this._logger.log(W.Warning,"Timeout from HTTP request."),G=new x},V)}if(K.content==="")K.content=void 0;if(K.content)if(K.headers=K.headers||{},k(K.content))K.headers["Content-Type"]="application/octet-stream";else K.headers["Content-Type"]="text/plain;charset=UTF-8";let Y;try{Y=await this._fetchType(K.url,{body:K.content,cache:"no-cache",credentials:K.withCredentials===!0?"include":"same-origin",headers:{"X-Requested-With":"XMLHttpRequest",...K.headers},method:K.method,mode:"cors",redirect:"follow",signal:$.signal})}catch(V){if(G)throw G;throw this._logger.log(W.Warning,`Error from HTTP request. ${V}.`),V}finally{if(Z)clearTimeout(Z);if(K.abortSignal)K.abortSignal.onabort=null}if(!Y.ok){let V=await WK(Y,"text");throw new S(V||Y.statusText,Y.status)}let J=await WK(Y,K.responseType);return new F(Y.status,Y.statusText,J)}getCookieString(K){let $="";if(w.isNode&&this._jar)this._jar.getCookies(K,(G,Z)=>$=Z.join("; "));return $}}function WK(K,$){let G;switch($){case"arraybuffer":G=K.arrayBuffer();break;case"text":G=K.text();break;case"blob":case"document":case"json":throw new Error(`${$} is not supported.`);default:G=K.text();break}return G}class n extends N{constructor(K){super();this._logger=K}send(K){if(K.abortSignal&&K.abortSignal.aborted)return Promise.reject(new A);if(!K.method)return Promise.reject(new Error("No method defined."));if(!K.url)return Promise.reject(new Error("No url defined."));return new Promise(($,G)=>{let Z=new XMLHttpRequest;if(Z.open(K.method,K.url,!0),Z.withCredentials=K.withCredentials===void 0?!0:K.withCredentials,Z.setRequestHeader("X-Requested-With","XMLHttpRequest"),K.content==="")K.content=void 0;if(K.content)if(k(K.content))Z.setRequestHeader("Content-Type","application/octet-stream");else Z.setRequestHeader("Content-Type","text/plain;charset=UTF-8");let Y=K.headers;if(Y)Object.keys(Y).forEach((X)=>{Z.setRequestHeader(X,Y[X])});if(K.responseType)Z.responseType=K.responseType;if(K.abortSignal)K.abortSignal.onabort=()=>{Z.abort(),G(new A)};if(K.timeout)Z.timeout=K.timeout;Z.onload=()=>{if(K.abortSignal)K.abortSignal.onabort=null;if(Z.status>=200&&Z.status<300)$(new F(Z.status,Z.statusText,Z.response||Z.responseText));else G(new S(Z.response||Z.responseText||Z.statusText,Z.status))},Z.onerror=()=>{this._logger.log(W.Warning,`Error from HTTP request. ${Z.status}: ${Z.statusText}.`),G(new S(Z.statusText,Z.status))},Z.ontimeout=()=>{this._logger.log(W.Warning,"Timeout from HTTP request."),G(new x)},Z.send(K.content)})}}class T extends N{constructor(K){super();if(typeof fetch!=="undefined"||w.isNode)this._httpClient=new g(K);else if(typeof XMLHttpRequest!=="undefined")this._httpClient=new n(K);else throw new Error("No usable HttpClient found.")}send(K){if(K.abortSignal&&K.abortSignal.aborted)return Promise.reject(new A);if(!K.method)return Promise.reject(new Error("No method defined."));if(!K.url)return Promise.reject(new Error("No url defined."));return this._httpClient.send(K)}getCookieString(K){return this._httpClient.getCookieString(K)}}class E{static write(K){return`${K}${E.RecordSeparator}`}static parse(K){if(K[K.length-1]!==E.RecordSeparator)throw new Error("Message is incomplete.");let $=K.split(E.RecordSeparator);return $.pop(),$}}E.RecordSeparatorCode=30;E.RecordSeparator=String.fromCharCode(E.RecordSeparatorCode);class a{writeHandshakeRequest(K){return E.write(JSON.stringify(K))}parseHandshakeResponse(K){let $,G;if(k(K)){let J=new Uint8Array(K),V=J.indexOf(E.RecordSeparatorCode);if(V===-1)throw new Error("Message is incomplete.");let Q=V+1;$=String.fromCharCode.apply(null,Array.prototype.slice.call(J.slice(0,Q))),G=J.byteLength>Q?J.slice(Q).buffer:null}else{let J=K,V=J.indexOf(E.RecordSeparator);if(V===-1)throw new Error("Message is incomplete.");let Q=V+1;$=J.substring(0,Q),G=J.length>Q?J.substring(Q):null}let Z=E.parse($),Y=JSON.parse(Z[0]);if(Y.type)throw new Error("Expected a handshake response from the server.");return[G,Y]}}var z;(function(K){K[K.Invocation=1]="Invocation",K[K.StreamItem=2]="StreamItem",K[K.Completion=3]="Completion",K[K.StreamInvocation=4]="StreamInvocation",K[K.CancelInvocation=5]="CancelInvocation",K[K.Ping=6]="Ping",K[K.Close=7]="Close",K[K.Ack=8]="Ack",K[K.Sequence=9]="Sequence"})(z||(z={}));class L{constructor(){this.observers=[]}next(K){for(let $ of this.observers)$.next(K)}error(K){for(let $ of this.observers)if($.error)$.error(K)}complete(){for(let K of this.observers)if(K.complete)K.complete()}subscribe(K){return this.observers.push(K),new l(this,K)}}class o{constructor(K,$,G){this._bufferSize=1e5,this._messages=[],this._totalMessageCount=0,this._waitForSequenceMessage=!1,this._nextReceivingSequenceId=1,this._latestReceivedSequenceId=0,this._bufferedByteCount=0,this._reconnectInProgress=!1,this._protocol=K,this._connection=$,this._bufferSize=G}async _send(K){let $=this._protocol.writeMessage(K),G=Promise.resolve();if(this._isInvocationMessage(K)){this._totalMessageCount++;let Z=()=>{},Y=()=>{};if(k($))this._bufferedByteCount+=$.byteLength;else this._bufferedByteCount+=$.length;if(this._bufferedByteCount>=this._bufferSize)G=new Promise((X,J)=>{Z=X,Y=J});this._messages.push(new XK($,this._totalMessageCount,Z,Y))}try{if(!this._reconnectInProgress)await this._connection.send($)}catch{this._disconnected()}await G}_ack(K){let $=-1;for(let G=0;G<this._messages.length;G++){let Z=this._messages[G];if(Z._id<=K.sequenceId){if($=G,k(Z._message))this._bufferedByteCount-=Z._message.byteLength;else this._bufferedByteCount-=Z._message.length;Z._resolver()}else if(this._bufferedByteCount<this._bufferSize)Z._resolver();else break}if($!==-1)this._messages=this._messages.slice($+1)}_shouldProcessMessage(K){if(this._waitForSequenceMessage)if(K.type!==z.Sequence)return!1;else return this._waitForSequenceMessage=!1,!0;if(!this._isInvocationMessage(K))return!0;let $=this._nextReceivingSequenceId;if(this._nextReceivingSequenceId++,$<=this._latestReceivedSequenceId){if($===this._latestReceivedSequenceId)this._ackTimer();return!1}return this._latestReceivedSequenceId=$,this._ackTimer(),!0}_resetSequence(K){if(K.sequenceId>this._nextReceivingSequenceId){this._connection.stop(new Error("Sequence ID greater than amount of messages we've received."));return}this._nextReceivingSequenceId=K.sequenceId}_disconnected(){this._reconnectInProgress=!0,this._waitForSequenceMessage=!0}async _resend(){let K=this._messages.length!==0?this._messages[0]._id:this._totalMessageCount+1;await this._connection.send(this._protocol.writeMessage({type:z.Sequence,sequenceId:K}));let $=this._messages;for(let G of $)await this._connection.send(G._message);this._reconnectInProgress=!1}_dispose(K){K!==null&&K!==void 0||(K=new Error("Unable to reconnect to server."));for(let $ of this._messages)$._rejector(K)}_isInvocationMessage(K){switch(K.type){case z.Invocation:case z.StreamItem:case z.Completion:case z.StreamInvocation:case z.CancelInvocation:return!0;case z.Close:case z.Sequence:case z.Ping:case z.Ack:return!1}}_ackTimer(){if(this._ackTimerHandle===void 0)this._ackTimerHandle=setTimeout(async()=>{try{if(!this._reconnectInProgress)await this._connection.send(this._protocol.writeMessage({type:z.Ack,sequenceId:this._latestReceivedSequenceId}))}catch{}clearTimeout(this._ackTimerHandle),this._ackTimerHandle=void 0},1000)}}class XK{constructor(K,$,G,Z){this._message=K,this._id=$,this._resolver=G,this._rejector=Z}}var OK=30000,DK=15000,UK=1e5,O;(function(K){K.Disconnected="Disconnected",K.Connecting="Connecting",K.Connected="Connected",K.Disconnecting="Disconnecting",K.Reconnecting="Reconnecting"})(O||(O={}));class q{static create(K,$,G,Z,Y,X,J){return new q(K,$,G,Z,Y,X,J)}constructor(K,$,G,Z,Y,X,J){this._nextKeepAlive=0,this._freezeEventListener=()=>{this._logger.log(W.Warning,"The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://learn.microsoft.com/aspnet/core/signalr/javascript-client#bsleep")},B.isRequired(K,"connection"),B.isRequired($,"logger"),B.isRequired(G,"protocol"),this.serverTimeoutInMilliseconds=Y!==null&&Y!==void 0?Y:OK,this.keepAliveIntervalInMilliseconds=X!==null&&X!==void 0?X:DK,this._statefulReconnectBufferSize=J!==null&&J!==void 0?J:UK,this._logger=$,this._protocol=G,this.connection=K,this._reconnectPolicy=Z,this._handshakeProtocol=new a,this.connection.onreceive=(V)=>this._processIncomingData(V),this.connection.onclose=(V)=>this._connectionClosed(V),this._callbacks={},this._methods={},this._closedCallbacks=[],this._reconnectingCallbacks=[],this._reconnectedCallbacks=[],this._invocationId=0,this._receivedHandshakeResponse=!1,this._connectionState=O.Disconnected,this._connectionStarted=!1,this._cachedPingMessage=this._protocol.writeMessage({type:z.Ping})}get state(){return this._connectionState}get connectionId(){return this.connection?this.connection.connectionId||null:null}get baseUrl(){return this.connection.baseUrl||""}set baseUrl(K){if(this._connectionState!==O.Disconnected&&this._connectionState!==O.Reconnecting)throw new Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url.");if(!K)throw new Error("The HubConnection url must be a valid url.");this.connection.baseUrl=K}start(){return this._startPromise=this._startWithStateTransitions(),this._startPromise}async _startWithStateTransitions(){if(this._connectionState!==O.Disconnected)return Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state."));this._connectionState=O.Connecting,this._logger.log(W.Debug,"Starting HubConnection.");try{if(await this._startInternal(),w.isBrowser)window.document.addEventListener("freeze",this._freezeEventListener);this._connectionState=O.Connected,this._connectionStarted=!0,this._logger.log(W.Debug,"HubConnection connected successfully.")}catch(K){return this._connectionState=O.Disconnected,this._logger.log(W.Debug,`HubConnection failed to start successfully because of error '${K}'.`),Promise.reject(K)}}async _startInternal(){this._stopDuringStartError=void 0,this._receivedHandshakeResponse=!1;let K=new Promise(($,G)=>{this._handshakeResolver=$,this._handshakeRejecter=G});await this.connection.start(this._protocol.transferFormat);try{let $=this._protocol.version;if(!this.connection.features.reconnect)$=1;let G={protocol:this._protocol.name,version:$};if(this._logger.log(W.Debug,"Sending handshake request."),await this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(G)),this._logger.log(W.Information,`Using HubProtocol '${this._protocol.name}'.`),this._cleanupTimeout(),this._resetTimeoutPeriod(),this._resetKeepAliveInterval(),await K,this._stopDuringStartError)throw this._stopDuringStartError;if(this.connection.features.reconnect||!1)this._messageBuffer=new o(this._protocol,this.connection,this._statefulReconnectBufferSize),this.connection.features.disconnected=this._messageBuffer._disconnected.bind(this._messageBuffer),this.connection.features.resend=()=>{if(this._messageBuffer)return this._messageBuffer._resend()};if(!this.connection.features.inherentKeepAlive)await this._sendMessage(this._cachedPingMessage)}catch($){throw this._logger.log(W.Debug,`Hub handshake failed with error '${$}' during start(). Stopping HubConnection.`),this._cleanupTimeout(),this._cleanupPingTimer(),await this.connection.stop($),$}}async stop(){let K=this._startPromise;this.connection.features.reconnect=!1,this._stopPromise=this._stopInternal(),await this._stopPromise;try{await K}catch($){}}_stopInternal(K){if(this._connectionState===O.Disconnected)return this._logger.log(W.Debug,`Call to HubConnection.stop(${K}) ignored because it is already in the disconnected state.`),Promise.resolve();if(this._connectionState===O.Disconnecting)return this._logger.log(W.Debug,`Call to HttpConnection.stop(${K}) ignored because the connection is already in the disconnecting state.`),this._stopPromise;let $=this._connectionState;if(this._connectionState=O.Disconnecting,this._logger.log(W.Debug,"Stopping HubConnection."),this._reconnectDelayHandle)return this._logger.log(W.Debug,"Connection stopped during reconnect delay. Done reconnecting."),clearTimeout(this._reconnectDelayHandle),this._reconnectDelayHandle=void 0,this._completeClose(),Promise.resolve();if($===O.Connected)this._sendCloseMessage();return this._cleanupTimeout(),this._cleanupPingTimer(),this._stopDuringStartError=K||new A("The connection was stopped before the hub handshake could complete."),this.connection.stop(K)}async _sendCloseMessage(){try{await this._sendWithProtocol(this._createCloseMessage())}catch{}}stream(K,...$){let[G,Z]=this._replaceStreamingParams($),Y=this._createStreamInvocation(K,$,Z),X,J=new L;return J.cancelCallback=()=>{let V=this._createCancelInvocation(Y.invocationId);return delete this._callbacks[Y.invocationId],X.then(()=>{return this._sendWithProtocol(V)})},this._callbacks[Y.invocationId]=(V,Q)=>{if(Q){J.error(Q);return}else if(V)if(V.type===z.Completion)if(V.error)J.error(new Error(V.error));else J.complete();else J.next(V.item)},X=this._sendWithProtocol(Y).catch((V)=>{J.error(V),delete this._callbacks[Y.invocationId]}),this._launchStreams(G,X),J}_sendMessage(K){return this._resetKeepAliveInterval(),this.connection.send(K)}_sendWithProtocol(K){if(this._messageBuffer)return this._messageBuffer._send(K);else return this._sendMessage(this._protocol.writeMessage(K))}send(K,...$){let[G,Z]=this._replaceStreamingParams($),Y=this._sendWithProtocol(this._createInvocation(K,$,!0,Z));return this._launchStreams(G,Y),Y}invoke(K,...$){let[G,Z]=this._replaceStreamingParams($),Y=this._createInvocation(K,$,!1,Z);return new Promise((J,V)=>{this._callbacks[Y.invocationId]=(_,P)=>{if(P){V(P);return}else if(_)if(_.type===z.Completion)if(_.error)V(new Error(_.error));else J(_.result);else V(new Error(`Unexpected message type: ${_.type}`))};let Q=this._sendWithProtocol(Y).catch((_)=>{V(_),delete this._callbacks[Y.invocationId]});this._launchStreams(G,Q)})}on(K,$){if(!K||!$)return;if(K=K.toLowerCase(),!this._methods[K])this._methods[K]=[];if(this._methods[K].indexOf($)!==-1)return;this._methods[K].push($)}off(K,$){if(!K)return;K=K.toLowerCase();let G=this._methods[K];if(!G)return;if($){let Z=G.indexOf($);if(Z!==-1){if(G.splice(Z,1),G.length===0)delete this._methods[K]}}else delete this._methods[K]}onclose(K){if(K)this._closedCallbacks.push(K)}onreconnecting(K){if(K)this._reconnectingCallbacks.push(K)}onreconnected(K){if(K)this._reconnectedCallbacks.push(K)}_processIncomingData(K){if(this._cleanupTimeout(),!this._receivedHandshakeResponse)K=this._processHandshakeResponse(K),this._receivedHandshakeResponse=!0;if(K){let $=this._protocol.parseMessages(K,this._logger);for(let G of $){if(this._messageBuffer&&!this._messageBuffer._shouldProcessMessage(G))continue;switch(G.type){case z.Invocation:this._invokeClientMethod(G).catch((Z)=>{this._logger.log(W.Error,`Invoke client method threw error: ${M(Z)}`)});break;case z.StreamItem:case z.Completion:{let Z=this._callbacks[G.invocationId];if(Z){if(G.type===z.Completion)delete this._callbacks[G.invocationId];try{Z(G)}catch(Y){this._logger.log(W.Error,`Stream callback threw error: ${M(Y)}`)}}break}case z.Ping:break;case z.Close:{this._logger.log(W.Information,"Close message received from server.");let Z=G.error?new Error("Server returned an error on close: "+G.error):void 0;if(G.allowReconnect===!0)this.connection.stop(Z);else this._stopPromise=this._stopInternal(Z);break}case z.Ack:if(this._messageBuffer)this._messageBuffer._ack(G);break;case z.Sequence:if(this._messageBuffer)this._messageBuffer._resetSequence(G);break;default:this._logger.log(W.Warning,`Invalid message type: ${G.type}.`);break}}}this._resetTimeoutPeriod()}_processHandshakeResponse(K){let $,G;try{[G,$]=this._handshakeProtocol.parseHandshakeResponse(K)}catch(Z){let Y="Error parsing handshake response: "+Z;this._logger.log(W.Error,Y);let X=new Error(Y);throw this._handshakeRejecter(X),X}if($.error){let Z="Server returned handshake error: "+$.error;this._logger.log(W.Error,Z);let Y=new Error(Z);throw this._handshakeRejecter(Y),Y}else this._logger.log(W.Debug,"Server handshake complete.");return this._handshakeResolver(),G}_resetKeepAliveInterval(){if(this.connection.features.inherentKeepAlive)return;this._nextKeepAlive=new Date().getTime()+this.keepAliveIntervalInMilliseconds,this._cleanupPingTimer()}_resetTimeoutPeriod(){if(!this.connection.features||!this.connection.features.inherentKeepAlive){if(this._timeoutHandle=setTimeout(()=>this.serverTimeout(),this.serverTimeoutInMilliseconds),this._pingServerHandle===void 0){let K=this._nextKeepAlive-new Date().getTime();if(K<0)K=0;this._pingServerHandle=setTimeout(async()=>{if(this._connectionState===O.Connected)try{await this._sendMessage(this._cachedPingMessage)}catch{this._cleanupPingTimer()}},K)}}}serverTimeout(){this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server."))}async _invokeClientMethod(K){let $=K.target.toLowerCase(),G=this._methods[$];if(!G){if(this._logger.log(W.Warning,`No client method with the name '${$}' found.`),K.invocationId)this._logger.log(W.Warning,`No result given for '${$}' method and invocation ID '${K.invocationId}'.`),await this._sendWithProtocol(this._createCompletionMessage(K.invocationId,"Client didn't provide a result.",null));return}let Z=G.slice(),Y=K.invocationId?!0:!1,X,J,V;for(let Q of Z)try{let _=X;if(X=await Q.apply(this,K.arguments),Y&&X&&_)this._logger.log(W.Error,`Multiple results provided for '${$}'. Sending error to server.`),V=this._createCompletionMessage(K.invocationId,"Client provided multiple results.",null);J=void 0}catch(_){J=_,this._logger.log(W.Error,`A callback for the method '${$}' threw error '${_}'.`)}if(V)await this._sendWithProtocol(V);else if(Y){if(J)V=this._createCompletionMessage(K.invocationId,`${J}`,null);else if(X!==void 0)V=this._createCompletionMessage(K.invocationId,null,X);else this._logger.log(W.Warning,`No result given for '${$}' method and invocation ID '${K.invocationId}'.`),V=this._createCompletionMessage(K.invocationId,"Client didn't provide a result.",null);await this._sendWithProtocol(V)}else if(X)this._logger.log(W.Error,`Result given for '${$}' method but server is not expecting a result.`)}_connectionClosed(K){if(this._logger.log(W.Debug,`HubConnection.connectionClosed(${K}) called while in state ${this._connectionState}.`),this._stopDuringStartError=this._stopDuringStartError||K||new A("The underlying connection was closed before the hub handshake could complete."),this._handshakeResolver)this._handshakeResolver();if(this._cancelCallbacksWithError(K||new Error("Invocation canceled due to the underlying connection being closed.")),this._cleanupTimeout(),this._cleanupPingTimer(),this._connectionState===O.Disconnecting)this._completeClose(K);else if(this._connectionState===O.Connected&&this._reconnectPolicy)this._reconnect(K);else if(this._connectionState===O.Connected)this._completeClose(K)}_completeClose(K){if(this._connectionStarted){if(this._connectionState=O.Disconnected,this._connectionStarted=!1,this._messageBuffer)this._messageBuffer._dispose(K!==null&&K!==void 0?K:new Error("Connection closed.")),this._messageBuffer=void 0;if(w.isBrowser)window.document.removeEventListener("freeze",this._freezeEventListener);try{this._closedCallbacks.forEach(($)=>$.apply(this,[K]))}catch($){this._logger.log(W.Error,`An onclose callback called with error '${K}' threw error '${$}'.`)}}}async _reconnect(K){let $=Date.now(),G=0,Z=K!==void 0?K:new Error("Attempting to reconnect due to a unknown error."),Y=this._getNextRetryDelay(G++,0,Z);if(Y===null){this._logger.log(W.Debug,"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt."),this._completeClose(K);return}if(this._connectionState=O.Reconnecting,K)this._logger.log(W.Information,`Connection reconnecting because of error '${K}'.`);else this._logger.log(W.Information,"Connection reconnecting.");if(this._reconnectingCallbacks.length!==0){try{this._reconnectingCallbacks.forEach((X)=>X.apply(this,[K]))}catch(X){this._logger.log(W.Error,`An onreconnecting callback called with error '${K}' threw error '${X}'.`)}if(this._connectionState!==O.Reconnecting){this._logger.log(W.Debug,"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.");return}}while(Y!==null){if(this._logger.log(W.Information,`Reconnect attempt number ${G} will start in ${Y} ms.`),await new Promise((X)=>{this._reconnectDelayHandle=setTimeout(X,Y)}),this._reconnectDelayHandle=void 0,this._connectionState!==O.Reconnecting){this._logger.log(W.Debug,"Connection left the reconnecting state during reconnect delay. Done reconnecting.");return}try{if(await this._startInternal(),this._connectionState=O.Connected,this._logger.log(W.Information,"HubConnection reconnected successfully."),this._reconnectedCallbacks.length!==0)try{this._reconnectedCallbacks.forEach((X)=>X.apply(this,[this.connection.connectionId]))}catch(X){this._logger.log(W.Error,`An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${X}'.`)}return}catch(X){if(this._logger.log(W.Information,`Reconnect attempt failed because of error '${X}'.`),this._connectionState!==O.Reconnecting){if(this._logger.log(W.Debug,`Connection moved to the '${this._connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`),this._connectionState===O.Disconnecting)this._completeClose();return}Z=X instanceof Error?X:new Error(X.toString()),Y=this._getNextRetryDelay(G++,Date.now()-$,Z)}}this._logger.log(W.Information,`Reconnect retries have been exhausted after ${Date.now()-$} ms and ${G} failed attempts. Connection disconnecting.`),this._completeClose()}_getNextRetryDelay(K,$,G){try{return this._reconnectPolicy.nextRetryDelayInMilliseconds({elapsedMilliseconds:$,previousRetryCount:K,retryReason:G})}catch(Z){return this._logger.log(W.Error,`IRetryPolicy.nextRetryDelayInMilliseconds(${K}, ${$}) threw error '${Z}'.`),null}}_cancelCallbacksWithError(K){let $=this._callbacks;this._callbacks={},Object.keys($).forEach((G)=>{let Z=$[G];try{Z(null,K)}catch(Y){this._logger.log(W.Error,`Stream 'error' callback called with '${K}' threw error: ${M(Y)}`)}})}_cleanupPingTimer(){if(this._pingServerHandle)clearTimeout(this._pingServerHandle),this._pingServerHandle=void 0}_cleanupTimeout(){if(this._timeoutHandle)clearTimeout(this._timeoutHandle)}_createInvocation(K,$,G,Z){if(G)if(Z.length!==0)return{arguments:$,streamIds:Z,target:K,type:z.Invocation};else return{arguments:$,target:K,type:z.Invocation};else{let Y=this._invocationId;if(this._invocationId++,Z.length!==0)return{arguments:$,invocationId:Y.toString(),streamIds:Z,target:K,type:z.Invocation};else return{arguments:$,invocationId:Y.toString(),target:K,type:z.Invocation}}}_launchStreams(K,$){if(K.length===0)return;if(!$)$=Promise.resolve();for(let G in K)K[G].subscribe({complete:()=>{$=$.then(()=>this._sendWithProtocol(this._createCompletionMessage(G)))},error:(Z)=>{let Y;if(Z instanceof Error)Y=Z.message;else if(Z&&Z.toString)Y=Z.toString();else Y="Unknown error";$=$.then(()=>this._sendWithProtocol(this._createCompletionMessage(G,Y)))},next:(Z)=>{$=$.then(()=>this._sendWithProtocol(this._createStreamItemMessage(G,Z)))}})}_replaceStreamingParams(K){let $=[],G=[];for(let Z=0;Z<K.length;Z++){let Y=K[Z];if(this._isObservable(Y)){let X=this._invocationId;this._invocationId++,$[X]=Y,G.push(X.toString()),K.splice(Z,1)}}return[$,G]}_isObservable(K){return K&&K.subscribe&&typeof K.subscribe==="function"}_createStreamInvocation(K,$,G){let Z=this._invocationId;if(this._invocationId++,G.length!==0)return{arguments:$,invocationId:Z.toString(),streamIds:G,target:K,type:z.StreamInvocation};else return{arguments:$,invocationId:Z.toString(),target:K,type:z.StreamInvocation}}_createCancelInvocation(K){return{invocationId:K,type:z.CancelInvocation}}_createStreamItemMessage(K,$){return{invocationId:K,item:$,type:z.StreamItem}}_createCompletionMessage(K,$,G){if($)return{error:$,invocationId:K,type:z.Completion};return{invocationId:K,result:G,type:z.Completion}}_createCloseMessage(){return{type:z.Close}}}var AK=[0,2000,1e4,30000,null];class d{constructor(K){this._retryDelays=K!==void 0?[...K,null]:AK}nextRetryDelayInMilliseconds(K){return this._retryDelays[K.previousRetryCount]}}class I{}I.Authorization="Authorization";I.Cookie="Cookie";class t extends N{constructor(K,$){super();this._innerClient=K,this._accessTokenFactory=$}async send(K){let $=!0;if(this._accessTokenFactory&&(!this._accessToken||K.url&&K.url.indexOf("/negotiate?")>0))$=!1,this._accessToken=await this._accessTokenFactory();this._setAuthorizationHeader(K);let G=await this._innerClient.send(K);if($&&G.statusCode===401&&this._accessTokenFactory)return this._accessToken=await this._accessTokenFactory(),this._setAuthorizationHeader(K),await this._innerClient.send(K);return G}_setAuthorizationHeader(K){if(!K.headers)K.headers={};if(this._accessToken)K.headers[I.Authorization]=`Bearer ${this._accessToken}`;else if(this._accessTokenFactory){if(K.headers[I.Authorization])delete K.headers[I.Authorization]}}getCookieString(K){return this._innerClient.getCookieString(K)}}var U;(function(K){K[K.None=0]="None",K[K.WebSockets=1]="WebSockets",K[K.ServerSentEvents=2]="ServerSentEvents",K[K.LongPolling=4]="LongPolling"})(U||(U={}));var D;(function(K){K[K.Text=1]="Text",K[K.Binary=2]="Binary"})(D||(D={}));class s{constructor(){this._isAborted=!1,this.onabort=null}abort(){if(!this._isAborted){if(this._isAborted=!0,this.onabort)this.onabort()}}get signal(){return this}get aborted(){return this._isAborted}}class v{get pollAborted(){return this._pollAbort.aborted}constructor(K,$,G){this._httpClient=K,this._logger=$,this._pollAbort=new s,this._options=G,this._running=!1,this.onreceive=null,this.onclose=null}async connect(K,$){if(B.isRequired(K,"url"),B.isRequired($,"transferFormat"),B.isIn($,D,"transferFormat"),this._url=K,this._logger.log(W.Trace,"(LongPolling transport) Connecting."),$===D.Binary&&(typeof XMLHttpRequest!=="undefined"&&typeof new XMLHttpRequest().responseType!=="string"))throw new Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported.");let[G,Z]=H(),Y={[G]:Z,...this._options.headers},X={abortSignal:this._pollAbort.signal,headers:Y,timeout:1e5,withCredentials:this._options.withCredentials};if($===D.Binary)X.responseType="arraybuffer";let J=`${K}&_=${Date.now()}`;this._logger.log(W.Trace,`(LongPolling transport) polling: ${J}.`);let V=await this._httpClient.get(J,X);if(V.statusCode!==200)this._logger.log(W.Error,`(LongPolling transport) Unexpected response code: ${V.statusCode}.`),this._closeError=new S(V.statusText||"",V.statusCode),this._running=!1;else this._running=!0;this._receiving=this._poll(this._url,X)}async _poll(K,$){try{while(this._running)try{let G=`${K}&_=${Date.now()}`;this._logger.log(W.Trace,`(LongPolling transport) polling: ${G}.`);let Z=await this._httpClient.get(G,$);if(Z.statusCode===204)this._logger.log(W.Information,"(LongPolling transport) Poll terminated by server."),this._running=!1;else if(Z.statusCode!==200)this._logger.log(W.Error,`(LongPolling transport) Unexpected response code: ${Z.statusCode}.`),this._closeError=new S(Z.statusText||"",Z.statusCode),this._running=!1;else if(Z.content){if(this._logger.log(W.Trace,`(LongPolling transport) data received. ${R(Z.content,this._options.logMessageContent)}.`),this.onreceive)this.onreceive(Z.content)}else this._logger.log(W.Trace,"(LongPolling transport) Poll timed out, reissuing.")}catch(G){if(!this._running)this._logger.log(W.Trace,`(LongPolling transport) Poll errored after shutdown: ${G.message}`);else if(G instanceof x)this._logger.log(W.Trace,"(LongPolling transport) Poll timed out, reissuing.");else this._closeError=G,this._running=!1}}finally{if(this._logger.log(W.Trace,"(LongPolling transport) Polling complete."),!this.pollAborted)this._raiseOnClose()}}async send(K){if(!this._running)return Promise.reject(new Error("Cannot send until the transport is connected"));return y(this._logger,"LongPolling",this._httpClient,this._url,K,this._options)}async stop(){this._logger.log(W.Trace,"(LongPolling transport) Stopping polling."),this._running=!1,this._pollAbort.abort();try{await this._receiving,this._logger.log(W.Trace,`(LongPolling transport) sending DELETE request to ${this._url}.`);let K={},[$,G]=H();K[$]=G;let Z={headers:{...K,...this._options.headers},timeout:this._options.timeout,withCredentials:this._options.withCredentials},Y;try{await this._httpClient.delete(this._url,Z)}catch(X){Y=X}if(Y){if(Y instanceof S)if(Y.statusCode===404)this._logger.log(W.Trace,"(LongPolling transport) A 404 response was returned from sending a DELETE request.");else this._logger.log(W.Trace,`(LongPolling transport) Error sending a DELETE request: ${Y}`)}else this._logger.log(W.Trace,"(LongPolling transport) DELETE request accepted.")}finally{this._logger.log(W.Trace,"(LongPolling transport) Stop finished."),this._raiseOnClose()}}_raiseOnClose(){if(this.onclose){let K="(LongPolling transport) Firing onclose event.";if(this._closeError)K+=" Error: "+this._closeError;this._logger.log(W.Trace,K),this.onclose(this._closeError)}}}class r{constructor(K,$,G,Z){this._httpClient=K,this._accessToken=$,this._logger=G,this._options=Z,this.onreceive=null,this.onclose=null}async connect(K,$){if(B.isRequired(K,"url"),B.isRequired($,"transferFormat"),B.isIn($,D,"transferFormat"),this._logger.log(W.Trace,"(SSE transport) Connecting."),this._url=K,this._accessToken)K+=(K.indexOf("?")<0?"?":"&")+`access_token=${encodeURIComponent(this._accessToken)}`;return new Promise((G,Z)=>{let Y=!1;if($!==D.Text){Z(new Error("The Server-Sent Events transport only supports the 'Text' transfer format"));return}let X;if(w.isBrowser||w.isWebWorker)X=new this._options.EventSource(K,{withCredentials:this._options.withCredentials});else{let J=this._httpClient.getCookieString(K),V={};V.Cookie=J;let[Q,_]=H();V[Q]=_,X=new this._options.EventSource(K,{withCredentials:this._options.withCredentials,headers:{...V,...this._options.headers}})}try{X.onmessage=(J)=>{if(this.onreceive)try{this._logger.log(W.Trace,`(SSE transport) data received. ${R(J.data,this._options.logMessageContent)}.`),this.onreceive(J.data)}catch(V){this._close(V);return}},X.onerror=(J)=>{if(Y)this._close();else Z(new Error("EventSource failed to connect. The connection could not be found on the server, either the connection ID is not present on the server, or a proxy is refusing/buffering the connection. If you have multiple servers check that sticky sessions are enabled."))},X.onopen=()=>{this._logger.log(W.Information,`SSE connected to ${this._url}`),this._eventSource=X,Y=!0,G()}}catch(J){Z(J);return}})}async send(K){if(!this._eventSource)return Promise.reject(new Error("Cannot send until the transport is connected"));return y(this._logger,"SSE",this._httpClient,this._url,K,this._options)}stop(){return this._close(),Promise.resolve()}_close(K){if(this._eventSource){if(this._eventSource.close(),this._eventSource=void 0,this.onclose)this.onclose(K)}}}class e{constructor(K,$,G,Z,Y,X){this._logger=G,this._accessTokenFactory=$,this._logMessageContent=Z,this._webSocketConstructor=Y,this._httpClient=K,this.onreceive=null,this.onclose=null,this._headers=X}async connect(K,$){B.isRequired(K,"url"),B.isRequired($,"transferFormat"),B.isIn($,D,"transferFormat"),this._logger.log(W.Trace,"(WebSockets transport) Connecting.");let G;if(this._accessTokenFactory)G=await this._accessTokenFactory();return new Promise((Z,Y)=>{K=K.replace(/^http/,"ws");let X,J=this._httpClient.getCookieString(K),V=!1;if(w.isNode||w.isReactNative){let Q={},[_,P]=H();if(Q[_]=P,G)Q[I.Authorization]=`Bearer ${G}`;if(J)Q[I.Cookie]=J;X=new this._webSocketConstructor(K,void 0,{headers:{...Q,...this._headers}})}else if(G)K+=(K.indexOf("?")<0?"?":"&")+`access_token=${encodeURIComponent(G)}`;if(!X)X=new this._webSocketConstructor(K);if($===D.Binary)X.binaryType="arraybuffer";X.onopen=(Q)=>{this._logger.log(W.Information,`WebSocket connected to ${K}.`),this._webSocket=X,V=!0,Z()},X.onerror=(Q)=>{let _=null;if(typeof ErrorEvent!=="undefined"&&Q instanceof ErrorEvent)_=Q.error;else _="There was an error with the transport";this._logger.log(W.Information,`(WebSockets transport) ${_}.`)},X.onmessage=(Q)=>{if(this._logger.log(W.Trace,`(WebSockets transport) data received. ${R(Q.data,this._logMessageContent)}.`),this.onreceive)try{this.onreceive(Q.data)}catch(_){this._close(_);return}},X.onclose=(Q)=>{if(V)this._close(Q);else{let _=null;if(typeof ErrorEvent!=="undefined"&&Q instanceof ErrorEvent)_=Q.error;else _="WebSocket failed to connect. The connection could not be found on the server, either the endpoint may not be a SignalR endpoint, the connection ID is not present on the server, or there is a proxy blocking WebSockets. If you have multiple servers check that sticky sessions are enabled.";Y(new Error(_))}}})}send(K){if(this._webSocket&&this._webSocket.readyState===this._webSocketConstructor.OPEN)return this._logger.log(W.Trace,`(WebSockets transport) sending data. ${R(K,this._logMessageContent)}.`),this._webSocket.send(K),Promise.resolve();return Promise.reject("WebSocket is not in the OPEN state")}stop(){if(this._webSocket)this._close(void 0);return Promise.resolve()}_close(K){if(this._webSocket)this._webSocket.onclose=()=>{},this._webSocket.onmessage=()=>{},this._webSocket.onerror=()=>{},this._webSocket.close(),this._webSocket=void 0;if(this._logger.log(W.Trace,"(WebSockets transport) socket closed."),this.onclose)if(this._isCloseEvent(K)&&(K.wasClean===!1||K.code!==1000))this.onclose(new Error(`WebSocket closed with status code: ${K.code} (${K.reason||"no reason given"}).`));else if(K instanceof Error)this.onclose(K);else this.onclose()}_isCloseEvent(K){return K&&typeof K.wasClean==="boolean"&&typeof K.code==="number"}}var JK=100;class KK{constructor(K,$={}){if(this._stopPromiseResolver=()=>{},this.features={},this._negotiateVersion=1,B.isRequired(K,"url"),this._logger=ZK($.logger),this.baseUrl=this._resolveUrl(K),$=$||{},$.logMessageContent=$.logMessageContent===void 0?!1:$.logMessageContent,typeof $.withCredentials==="boolean"||$.withCredentials===void 0)$.withCredentials=$.withCredentials===void 0?!0:$.withCredentials;else throw new Error("withCredentials option was not a 'boolean' or 'undefined' value");$.timeout=$.timeout===void 0?1e5:$.timeout;let G=null,Z=null;if(w.isNode){let Y=typeof __webpack_require__==="function"?__non_webpack_require__:j;G=Y("ws"),Z=Y("eventsource")}if(!w.isNode&&typeof WebSocket!=="undefined"&&!$.WebSocket)$.WebSocket=WebSocket;else if(w.isNode&&!$.WebSocket){if(G)$.WebSocket=G}if(!w.isNode&&typeof EventSource!=="undefined"&&!$.EventSource)$.EventSource=EventSource;else if(w.isNode&&!$.EventSource){if(typeof Z!=="undefined")$.EventSource=Z}this._httpClient=new t($.httpClient||new T(this._logger),$.accessTokenFactory),this._connectionState="Disconnected",this._connectionStarted=!1,this._options=$,this.onreceive=null,this.onclose=null}async start(K){if(K=K||D.Binary,B.isIn(K,D,"transferFormat"),this._logger.log(W.Debug,`Starting connection with transfer format '${D[K]}'.`),this._connectionState!=="Disconnected")return Promise.reject(new Error("Cannot start an HttpConnection that is not in the 'Disconnected' state."));if(this._connectionState="Connecting",this._startInternalPromise=this._startInternal(K),await this._startInternalPromise,this._connectionState==="Disconnecting")return this._logger.log(W.Error,"Failed to start the HttpConnection before stop() was called."),await this._stopPromise,Promise.reject(new A("Failed to start the HttpConnection before stop() was called."));else if(this._connectionState!=="Connected")return this._logger.log(W.Error,"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!"),Promise.reject(new A("HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!"));this._connectionStarted=!0}send(K){if(this._connectionState!=="Connected")return Promise.reject(new Error("Cannot send data if the connection is not in the 'Connected' State."));if(!this._sendQueue)this._sendQueue=new $K(this.transport);return this._sendQueue.send(K)}async stop(K){if(this._connectionState==="Disconnected")return this._logger.log(W.Debug,`Call to HttpConnection.stop(${K}) ignored because the connection is already in the disconnected state.`),Promise.resolve();if(this._connectionState==="Disconnecting")return this._logger.log(W.Debug,`Call to HttpConnection.stop(${K}) ignored because the connection is already in the disconnecting state.`),this._stopPromise;this._connectionState="Disconnecting",this._stopPromise=new Promise(($)=>{this._stopPromiseResolver=$}),await this._stopInternal(K),await this._stopPromise}async _stopInternal(K){this._stopError=K;try{await this._startInternalPromise}catch($){}if(this.transport){try{await this.transport.stop()}catch($){this._logger.log(W.Error,`HttpConnection.transport.stop() threw error '${$}'.`),this._stopConnection()}this.transport=void 0}else this._logger.log(W.Debug,"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.")}async _startInternal(K){let $=this.baseUrl;this._accessTokenFactory=this._options.accessTokenFactory,this._httpClient._accessTokenFactory=this._accessTokenFactory;try{if(this._options.skipNegotiation)if(this._options.transport===U.WebSockets)this.transport=this._constructTransport(U.WebSockets),await this._startTransport($,K);else throw new Error("Negotiation can only be skipped when using the WebSocket transport directly.");else{let G=null,Z=0;do{if(G=await this._getNegotiationResponse($),this._connectionState==="Disconnecting"||this._connectionState==="Disconnected")throw new A("The connection was stopped during negotiation.");if(G.error)throw new Error(G.error);if(G.ProtocolVersion)throw new Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.");if(G.url)$=G.url;if(G.accessToken){let Y=G.accessToken;this._accessTokenFactory=()=>Y,this._httpClient._accessToken=Y,this._httpClient._accessTokenFactory=void 0}Z++}while(G.url&&Z<JK);if(Z===JK&&G.url)throw new Error("Negotiate redirection limit exceeded.");await this._createTransport($,this._options.transport,G,K)}if(this.transport instanceof v)this.features.inherentKeepAlive=!0;if(this._connectionState==="Connecting")this._logger.log(W.Debug,"The HttpConnection connected successfully."),this._connectionState="Connected"}catch(G){return this._logger.log(W.Error,"Failed to start the connection: "+G),this._connectionState="Disconnected",this.transport=void 0,this._stopPromiseResolver(),Promise.reject(G)}}async _getNegotiationResponse(K){let $={},[G,Z]=H();$[G]=Z;let Y=this._resolveNegotiateUrl(K);this._logger.log(W.Debug,`Sending negotiation request: ${Y}.`);try{let X=await this._httpClient.post(Y,{content:"",headers:{...$,...this._options.headers},timeout:this._options.timeout,withCredentials:this._options.withCredentials});if(X.statusCode!==200)return Promise.reject(new Error(`Unexpected status code returned from negotiate '${X.statusCode}'`));let J=JSON.parse(X.content);if(!J.negotiateVersion||J.negotiateVersion<1)J.connectionToken=J.connectionId;if(J.useStatefulReconnect&&this._options._useStatefulReconnect!==!0)return Promise.reject(new f("Client didn't negotiate Stateful Reconnect but the server did."));return J}catch(X){let J="Failed to complete negotiation with the server: "+X;if(X instanceof S){if(X.statusCode===404)J=J+" Either this is not a SignalR endpoint or there is a proxy blocking the connection."}return this._logger.log(W.Error,J),Promise.reject(new f(J))}}_createConnectUrl(K,$){if(!$)return K;return K+(K.indexOf("?")===-1?"?":"&")+`id=${$}`}async _createTransport(K,$,G,Z){let Y=this._createConnectUrl(K,G.connectionToken);if(this._isITransport($)){this._logger.log(W.Debug,"Connection was provided an instance of ITransport, using that directly."),this.transport=$,await this._startTransport(Y,Z),this.connectionId=G.connectionId;return}let X=[],J=G.availableTransports||[],V=G;for(let Q of J){let _=this._resolveTransportOrError(Q,$,Z,(V===null||V===void 0?void 0:V.useStatefulReconnect)===!0);if(_ instanceof Error)X.push(`${Q.transport} failed:`),X.push(_);else if(this._isITransport(_)){if(this.transport=_,!V){try{V=await this._getNegotiationResponse(K)}catch(P){return Promise.reject(P)}Y=this._createConnectUrl(K,V.connectionToken)}try{await this._startTransport(Y,Z),this.connectionId=V.connectionId;return}catch(P){if(this._logger.log(W.Error,`Failed to start the transport '${Q.transport}': ${P}`),V=void 0,X.push(new p(`${Q.transport} failed: ${P}`,U[Q.transport])),this._connectionState!=="Connecting")return this._logger.log(W.Debug,"Failed to select transport before stop() was called."),Promise.reject(new A("Failed to select transport before stop() was called."))}}}if(X.length>0)return Promise.reject(new i(`Unable to connect to the server with any of the available transports. ${X.join(" ")}`,X));return Promise.reject(new Error("None of the transports supported by the client are supported by the server."))}_constructTransport(K){switch(K){case U.WebSockets:if(!this._options.WebSocket)throw new Error("'WebSocket' is not supported in your environment.");return new e(this._httpClient,this._accessTokenFactory,this._logger,this._options.logMessageContent,this._options.WebSocket,this._options.headers||{});case U.ServerSentEvents:if(!this._options.EventSource)throw new Error("'EventSource' is not supported in your environment.");return new r(this._httpClient,this._httpClient._accessToken,this._logger,this._options);case U.LongPolling:return new v(this._httpClient,this._logger,this._options);default:throw new Error(`Unknown transport: ${K}.`)}}_startTransport(K,$){if(this.transport.onreceive=this.onreceive,this.features.reconnect)this.transport.onclose=async(G)=>{let Z=!1;if(this.features.reconnect)try{this.features.disconnected(),await this.transport.connect(K,$),await this.features.resend()}catch{Z=!0}else{this._stopConnection(G);return}if(Z)this._stopConnection(G)};else this.transport.onclose=(G)=>this._stopConnection(G);return this.transport.connect(K,$)}_resolveTransportOrError(K,$,G,Z){let Y=U[K.transport];if(Y===null||Y===void 0)return this._logger.log(W.Debug,`Skipping transport '${K.transport}' because it is not supported by this client.`),new Error(`Skipping transport '${K.transport}' because it is not supported by this client.`);else if(EK($,Y))if(K.transferFormats.map((J)=>D[J]).indexOf(G)>=0)if(Y===U.WebSockets&&!this._options.WebSocket||Y===U.ServerSentEvents&&!this._options.EventSource)return this._logger.log(W.Debug,`Skipping transport '${U[Y]}' because it is not supported in your environment.'`),new m(`'${U[Y]}' is not supported in your environment.`,Y);else{this._logger.log(W.Debug,`Selecting transport '${U[Y]}'.`);try{return this.features.reconnect=Y===U.WebSockets?Z:void 0,this._constructTransport(Y)}catch(J){return J}}else return this._logger.log(W.Debug,`Skipping transport '${U[Y]}' because it does not support the requested transfer format '${D[G]}'.`),new Error(`'${U[Y]}' does not support ${D[G]}.`);else return this._logger.log(W.Debug,`Skipping transport '${U[Y]}' because it was disabled by the client.`),new u(`'${U[Y]}' is disabled by the client.`,Y)}_isITransport(K){return K&&typeof K==="object"&&"connect"in K}_stopConnection(K){if(this._logger.log(W.Debug,`HttpConnection.stopConnection(${K}) called while in state ${this._connectionState}.`),this.transport=void 0,K=this._stopError||K,this._stopError=void 0,this._connectionState==="Disconnected"){this._logger.log(W.Debug,`Call to HttpConnection.stopConnection(${K}) was ignored because the connection is already in the disconnected state.`);return}if(this._connectionState==="Connecting")throw this._logger.log(W.Warning,`Call to HttpConnection.stopConnection(${K}) was ignored because the connection is still in the connecting state.`),new Error(`HttpConnection.stopConnection(${K}) was called while the connection is still in the connecting state.`);if(this._connectionState==="Disconnecting")this._stopPromiseResolver();if(K)this._logger.log(W.Error,`Connection disconnected with error '${K}'.`);else this._logger.log(W.Information,"Connection disconnected.");if(this._sendQueue)this._sendQueue.stop().catch(($)=>{this._logger.log(W.Error,`TransportSendQueue.stop() threw error '${$}'.`)}),this._sendQueue=void 0;if(this.connectionId=void 0,this._connectionState="Disconnected",this._connectionStarted){this._connectionStarted=!1;try{if(this.onclose)this.onclose(K)}catch($){this._logger.log(W.Error,`HttpConnection.onclose(${K}) threw error '${$}'.`)}}}_resolveUrl(K){if(K.lastIndexOf("https://",0)===0||K.lastIndexOf("http://",0)===0)return K;if(!w.isBrowser)throw new Error(`Cannot resolve '${K}'.`);let $=window.document.createElement("a");return $.href=K,this._logger.log(W.Information,`Normalizing '${K}' to '${$.href}'.`),$.href}_resolveNegotiateUrl(K){let $=new URL(K);if($.pathname.endsWith("/"))$.pathname+="negotiate";else $.pathname+="/negotiate";let G=new URLSearchParams($.searchParams);if(!G.has("negotiateVersion"))G.append("negotiateVersion",this._negotiateVersion.toString());if(G.has("useStatefulReconnect")){if(G.get("useStatefulReconnect")==="true")this._options._useStatefulReconnect=!0}else if(this._options._useStatefulReconnect===!0)G.append("useStatefulReconnect","true");return $.search=G.toString(),$.toString()}}function EK(K,$){return!K||($&K)!==0}class $K{constructor(K){this._transport=K,this._buffer=[],this._executing=!0,this._sendBufferedData=new h,this._transportResult=new h,this._sendLoopPromise=this._sendLoop()}send(K){if(this._bufferData(K),!this._transportResult)this._transportResult=new h;return this._transportResult.promise}stop(){return this._executing=!1,this._sendBufferedData.resolve(),this._sendLoopPromise}_bufferData(K){if(this._buffer.length&&typeof this._buffer[0]!==typeof K)throw new Error(`Expected data to be of type ${typeof this._buffer} but was of type ${typeof K}`);this._buffer.push(K),this._sendBufferedData.resolve()}async _sendLoop(){while(!0){if(await this._sendBufferedData.promise,!this._executing){if(this._transportResult)this._transportResult.reject("Connection stopped.");break}this._sendBufferedData=new h;let K=this._transportResult;this._transportResult=void 0;let $=typeof this._buffer[0]==="string"?this._buffer.join(""):$K._concatBuffers(this._buffer);this._buffer.length=0;try{await this._transport.send($),K.resolve()}catch(G){K.reject(G)}}}static _concatBuffers(K){let $=K.map((Y)=>Y.byteLength).reduce((Y,X)=>Y+X),G=new Uint8Array($),Z=0;for(let Y of K)G.set(new Uint8Array(Y),Z),Z+=Y.byteLength;return G.buffer}}class h{constructor(){this.promise=new Promise((K,$)=>[this._resolver,this._rejecter]=[K,$])}resolve(){this._resolver()}reject(K){this._rejecter(K)}}var SK="json";class c{constructor(){this.name=SK,this.version=2,this.transferFormat=D.Text}parseMessages(K,$){if(typeof K!=="string")throw new Error("Invalid input for JSON hub protocol. Expected a string.");if(!K)return[];if($===null)$=C.instance;let G=E.parse(K),Z=[];for(let Y of G){let X=JSON.parse(Y);if(typeof X.type!=="number")throw new Error("Invalid payload.");switch(X.type){case z.Invocation:this._isInvocationMessage(X);break;case z.StreamItem:this._isStreamItemMessage(X);break;case z.Completion:this._isCompletionMessage(X);break;case z.Ping:break;case z.Close:break;case z.Ack:this._isAckMessage(X);break;case z.Sequence:this._isSequenceMessage(X);break;default:$.log(W.Information,"Unknown message type '"+X.type+"' ignored.");continue}Z.push(X)}return Z}writeMessage(K){return E.write(JSON.stringify(K))}_isInvocationMessage(K){if(this._assertNotEmptyString(K.target,"Invalid payload for Invocation message."),K.invocationId!==void 0)this._assertNotEmptyString(K.invocationId,"Invalid payload for Invocation message.")}_isStreamItemMessage(K){if(this._assertNotEmptyString(K.invocationId,"Invalid payload for StreamItem message."),K.item===void 0)throw new Error("Invalid payload for StreamItem message.")}_isCompletionMessage(K){if(K.result&&K.error)throw new Error("Invalid payload for Completion message.");if(!K.result&&K.error)this._assertNotEmptyString(K.error,"Invalid payload for Completion message.");this._assertNotEmptyString(K.invocationId,"Invalid payload for Completion message.")}_isAckMessage(K){if(typeof K.sequenceId!=="number")throw new Error("Invalid SequenceId for Ack message.")}_isSequenceMessage(K){if(typeof K.sequenceId!=="number")throw new Error("Invalid SequenceId for Sequence message.")}_assertNotEmptyString(K,$){if(typeof K!=="string"||K==="")throw new Error($)}}var PK={trace:W.Trace,debug:W.Debug,info:W.Information,information:W.Information,warn:W.Warning,warning:W.Warning,error:W.Error,critical:W.Critical,none:W.None};function kK(K){let $=PK[K.toLowerCase()];if(typeof $!=="undefined")return $;else throw new Error(`Unknown log level: ${K}`)}class VK{configureLogging(K){if(B.isRequired(K,"logging"),NK(K))this.logger=K;else if(typeof K==="string"){let $=kK(K);this.logger=new b($)}else this.logger=new b(K);return this}withUrl(K,$){if(B.isRequired(K,"url"),B.isNotEmpty(K,"url"),this.url=K,typeof $==="object")this.httpConnectionOptions={...this.httpConnectionOptions,...$};else this.httpConnectionOptions={...this.httpConnectionOptions,transport:$};return this}withHubProtocol(K){return B.isRequired(K,"protocol"),this.protocol=K,this}withAutomaticReconnect(K){if(this.reconnectPolicy)throw new Error("A reconnectPolicy has already been set.");if(!K)this.reconnectPolicy=new d;else if(Array.isArray(K))this.reconnectPolicy=new d(K);else this.reconnectPolicy=K;return this}withServerTimeout(K){return B.isRequired(K,"milliseconds"),this._serverTimeoutInMilliseconds=K,this}withKeepAliveInterval(K){return B.isRequired(K,"milliseconds"),this._keepAliveIntervalInMilliseconds=K,this}withStatefulReconnect(K){if(this.httpConnectionOptions===void 0)this.httpConnectionOptions={};return this.httpConnectionOptions._useStatefulReconnect=!0,this._statefulReconnectBufferSize=K===null||K===void 0?void 0:K.bufferSize,this}build(){let K=this.httpConnectionOptions||{};if(K.logger===void 0)K.logger=this.logger;if(!this.url)throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection.");let $=new KK(this.url,K);return q.create($,this.logger||C.instance,this.protocol||new c,this.reconnectPolicy,this._serverTimeoutInMilliseconds,this._keepAliveIntervalInMilliseconds,this._statefulReconnectBufferSize)}}function NK(K){return K.log!==void 0}export{GK as VERSION,D as TransferFormat,x as TimeoutError,L as Subject,C as NullLogger,z as MessageType,W as LogLevel,c as JsonHubProtocol,O as HubConnectionState,VK as HubConnectionBuilder,q as HubConnection,U as HttpTransportType,F as HttpResponse,S as HttpError,N as HttpClient,T as DefaultHttpClient,A as AbortError};
